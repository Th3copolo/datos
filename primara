


import numpy as np
import pandas as pd
import math
from sklearn.model_selection import train_test_split

# Función para calcular la distancia euclidiana entre dos puntos
def distancia_euclidiana(point1, point2):
    distance = 0.0
    for i in range(len(point1)):
        distance += (point1[i] - point2[i]) ** 2
    return math.sqrt(distance)

# Importar datos
iris = pd.read_csv("irisne.csv")

# Separar todas las columnas de las que quiero predecir
X = iris.drop('Species', axis=1).values
y = np.array(iris['Species'])

# Separar los datos de "train" en entrenamiento 
# y prueba para probar los algoritmos
# 70% entrenamiento y 30% prueba
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.30)
print("Datos de entrenamiento y prueba creados")
print("Son {} datos para entrenamiento y {} datos para prueba".format(X_train.shape[0], X_test.shape[0]))

# Clasificador de distancia mínima
class ClasificadorDistanciaMinima:
    def fit(self, X, y):
        self.X_train = X
        self.y_train = y

    def predict(self, X):
        y_pred = []
        for sample in X:
            min_distance = float('inf')
            nearest_label = None
            for i, train_sample in enumerate(self.X_train):
                distance = distancia_euclidiana(sample, train_sample)
                if distance < min_distance:
                    min_distance = distance
                    nearest_label = self.y_train[i]
            y_pred.append(nearest_label)
        return y_pred

# Crear una instancia del clasificador de distancia mínima
min_distance = ClasificadorDistanciaMinima()

# Entrenar el clasificador con los datos de entrenamiento
min_distance.fit(X_train, y_train)

# Realizar predicciones en los datos de prueba
y_pred = min_distance.predict(X_test)

# Calcular la precisión del modelo en los datos de prueba
accuracy = np.mean(y_pred == y_test)
print("Precisión de la clasificación de distancia mínima: {}".format(accuracy))

# Método de validación Leave-One-Out (LOO)
n_samples = len(X)
correct_predictions_loo = 0

for i in range(n_samples):
    X_train_loo = np.delete(X, i, axis=0)
    y_train_loo = np.delete(y, i)
    X_test_loo = X[i].reshape(1, -1)
    y_test_loo = y[i]

    # Crear una instancia del clasificador de mínima distancia para LOO
    min_distance_loo = ClasificadorDistanciaMinima()

    # Entrenar el clasificador con los datos de entrenamiento para LOO
    min_distance_loo.fit(X_train_loo, y_train_loo)

    # Realizar predicciones en el dato de prueba para LOO
    y_pred_loo = min_distance_loo.predict(X_test_loo)

    # Comparar la etiqueta predicha con la etiqueta real para LOO
    if y_pred_loo[0] == y_test_loo:
        correct_predictions_loo += 1

accuracy_loo = correct_predictions_loo / n_samples
print("Precisión Distancia Minima (Leave-One-Out): {}"
      .format(accuracy_loo)) 


---------------------------------------------------------------------------------
import numpy as np
import pandas as pd
import math
from sklearn.model_selection import train_test_split

# Función para calcular la distancia euclidiana entre dos puntos
def distancia_euclidiana(point1, point2):
    distance = 0.0
    for i in range(len(point1)):
        distance += (point1[i] - point2[i]) ** 2
    return math.sqrt(distance)

# Importar datos
iris = pd.read_csv("irisne.csv")

# Separar todas las columnas de las que quiero predecir
X = iris.drop('Species', axis=1).values
y = np.array(iris['Species'])

# Separar los datos de "train" en entrenamiento 
# y prueba para probar los algoritmos
# 70% entrenamiento y 30% prueba
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.30)
print("Datos de entrenamiento y prueba creados")
print("Son {} datos para entrenamiento y {} datos para prueba".format(X_train.shape[0], X_test.shape[0]))

# Clasificador de distancia mínima
class ClasificadorDistanciaMinima:
    def fit(self, X, y):
        self.X_train = X
        self.y_train = y

    def predict(self, X):
        y_pred = []
        for sample in X:
            min_distance = float('inf')
            nearest_label = None
            for i, train_sample in enumerate(self.X_train):
                distance = distancia_euclidiana(sample, train_sample)
                if distance < min_distance:
                    min_distance = distance
                    nearest_label = self.y_train[i]
            y_pred.append(nearest_label)
        return y_pred

# Crear una instancia del clasificador de distancia mínima
min_distance = ClasificadorDistanciaMinima()

# Entrenar el clasificador con los datos de entrenamiento
min_distance.fit(X_train, y_train)

# Realizar predicciones en los datos de prueba
y_pred = min_distance.predict(X_test)

# Calcular la precisión del modelo en los datos de prueba
accuracy = np.mean(y_pred == y_test)
print("Precisión de la clasificación de distancia mínima: {}".format(accuracy))

# Método de validación Leave-One-Out (LOO)
n_samples = len(X)
correct_predictions_loo = 0

for i in range(n_samples):
    X_train_loo = np.delete(X, i, axis=0)
    y_train_loo = np.delete(y, i)
    X_test_loo = X[i].reshape(1, -1)
    y_test_loo = y[i]

    # Crear una instancia del clasificador de mínima distancia para LOO
    min_distance_loo = ClasificadorDistanciaMinima()

    # Entrenar el clasificador con los datos de entrenamiento para LOO
    min_distance_loo.fit(X_train_loo, y_train_loo)

    # Realizar predicciones en el dato de prueba para LOO
    y_pred_loo = min_distance_loo.predict(X_test_loo)

    # Comparar la etiqueta predicha con la etiqueta real para LOO
    if y_pred_loo[0] == y_test_loo:
        correct_predictions_loo += 1

accuracy_loo = correct_predictions_loo / n_samples
print("Precisión Distancia Minima (Leave-One-Out): {}"
      .format(accuracy_loo))

---------------------------------------------------------------------------------

import numpy as np
import pandas as pd
import math
from sklearn.model_selection import train_test_split

# Función para calcular la distancia euclidiana entre dos puntos
def distancia_euclidiana(point1, point2):
    distance = 0.0
    for i in range(len(point1)):
        distance += (point1[i] - point2[i]) ** 2
    return math.sqrt(distance)

# Importar datos
iris = pd.read_csv("irisne.csv")

# Separar todas las columnas de las que quiero predecir
X = iris.drop('Species', axis=1).values
y = np.array(iris['Species'])

# Separar los datos de "train" en entrenamiento 
# y prueba para probar los algoritmos
# 70% entrenamiento y 30% prueba
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.30)
print("Datos de entrenamiento y prueba creados")
print("Son {} datos para entrenamiento y {} datos para prueba".format(X_train.shape[0], X_test.shape[0]))

# Clasificador KNN
class ClasificadorKNN:
    def _init_(self, n_neighbors=1):
        self.n_neighbors = n_neighbors

    def fit(self, X, y):
        self.X_train = X
        self.y_train = y

    def predict(self, X):
        y_pred = []
        for sample in X:
            distances = []
            for i, train_sample in enumerate(self.X_train):
                distance = distancia_euclidiana(sample, train_sample)
                distances.append((distance, self.y_train[i]))

            distances.sort(key=lambda x: x[0])
            neighbors = distances[:self.n_neighbors]
            neighbor_labels = [neighbor[1] for neighbor in neighbors]
            prediction = max(set(neighbor_labels), key=neighbor_labels.count)
            y_pred.append(prediction)
        return y_pred

# Pedir al usuario el número de vecinos a considerar
n_neighbors_input = int(input("Introduce el número de vecinos a considerar: "))

# Crear una instancia del clasificador KNN con el número de vecinos especificado
knn_classifier = ClasificadorKNN(n_neighbors=n_neighbors_input)

# Entrenar el clasificador con los datos de entrenamiento
knn_classifier.fit(X_train, y_train)

# Realizar predicciones en los datos de prueba
y_pred = knn_classifier.predict(X_test)

# Calcular la precisión del modelo en los datos de prueba
accuracy = np.mean(y_pred == y_test)
print("Precisión del clasificador KNN con {} vecinos: {}".format(n_neighbors_input, accuracy)) y este import numpy as np
import pandas as pd

# Función para cargar el archivo de texto plano
def cargardatos(archivo, delimitador):
    data=pd.read_csv(archivo, delimiter=delimitador)
    return data

#Funcion para imprimir en el txt
def imprimirtxt(datos_array, tipos_de_datos, vector_atributos, matriz_patrones, matriz_patrones_reducida):
    with open('impresion.txt', 'w') as archivo:
        archivo.write('Informacion completa del dataset\n')
        archivo.write(str(datos_array))
        archivo.write("\n\nInformacion de el tipo de datos de los atributos del dataset\n")
        archivo.write(str(tipos_de_datos))
        archivo.write("\n\nAtributos selecionados del dataset\n")
        archivo.write(str(vector_atributos))
        archivo.write("\n\nMatriz que muestra los patrones seleccionados\n")
        archivo.write(str(matriz_patrones))
        archivo.write("\n\nMatriz que muestra los patrones seleccionados reducidos con base en los atributos seleccionados\n")
        archivo.write(str(matriz_patrones_reducida))
        archivo.write("\n")

def main():
    archivo=input("Escriba el nombre del archivo de donde obtendremos la informacion: ")
    delimitador=input("Seleccione cual es el signo delimitador del archivo: ") 
    datos=cargardatos(archivo,delimitador)
    num_filas, num_columnas = datos.shape
    print(f"El DataFrame tiene {num_filas} patrones y {num_columnas} atributos.")
    tipos_de_datos = datos.dtypes
    #Seleccionamos atributos al azar para generar el vector
    limite_inferior_1 = int(input(f"Seleccione el limite inferior (Valores entre 0 y {num_columnas}) para generar el vector de attributos: "))
    limite_superior_1 = int(input(f"Ahora el limite superior (Valores entre {limite_inferior_1} y {num_columnas}): "))
    vector_atributos= list(datos.columns[limite_inferior_1:limite_superior_1])
    #Seleccionamos patrones al azar para generar la matriz
    limite_inferior_2 = int(input(f"Seleccione el limite inferior (Valores entre 0 y {num_filas}) para generar la matriz de patrones: "))
    limite_superior_2 = int(input(f"Ahora el limite superior (Valores entre {limite_inferior_2} y {num_filas}): "))
    matriz_patrones= datos.iloc[limite_inferior_2:limite_superior_2]
    matriz_patrones=matriz_patrones.values
    matriz_patrones_reducida = matriz_patrones[:, limite_inferior_1:limite_superior_1]
    datos_array=np.array(datos)
    imprimirtxt(datos_array, tipos_de_datos,vector_atributos,matriz_patrones,matriz_patrones_reducida)
    print("Se ha impreso correctamente la informacion en el archivo de texto!")
main()
